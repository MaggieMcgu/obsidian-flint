/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FlintPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  sourceFolder: "",
  outputFolder: "",
  includeOrphans: true,
  showEssayProjects: true,
  sparkHistory: []
};
function sanitizeFilename(name) {
  return name.replace(/[/\\:*?"<>|]/g, "").trim();
}
function getRandomNote(exclude, app, settings) {
  let pool = app.vault.getMarkdownFiles();
  if (settings.sourceFolder) {
    const prefix = settings.sourceFolder + "/";
    pool = pool.filter((f) => f.path.startsWith(prefix));
  }
  const recentPaths = /* @__PURE__ */ new Set([
    ...exclude,
    ...settings.sparkHistory.slice(-10).flatMap((e) => [e.noteA, e.noteB])
  ]);
  pool = pool.filter((f) => !recentPaths.has(f.path));
  if (pool.length === 0)
    return null;
  if (settings.includeOrphans) {
    pool.sort((a, b) => {
      const aLinks = Object.keys(
        app.metadataCache.resolvedLinks[a.path] || {}
      ).length;
      const bLinks = Object.keys(
        app.metadataCache.resolvedLinks[b.path] || {}
      ).length;
      return aLinks - bLinks;
    });
    const halfPool = pool.slice(0, Math.max(1, Math.ceil(pool.length * 0.5)));
    return halfPool[Math.floor(Math.random() * halfPool.length)];
  }
  return pool[Math.floor(Math.random() * pool.length)];
}
async function getCairnProjects(app) {
  const dataPath = ".obsidian/plugins/note-assembler/data.json";
  const file = app.vault.getAbstractFileByPath(dataPath);
  if (!file || !(file instanceof import_obsidian.TFile))
    return [];
  try {
    const raw = await app.vault.read(file);
    const data = JSON.parse(raw);
    return data.projects || [];
  } catch (e) {
    return [];
  }
}
var NotePickerModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, sourceFolder, onChoose) {
    super(app);
    this.sourceFolder = sourceFolder;
    this.onChooseFile = onChoose;
    this.setPlaceholder("Pick a note\u2026");
  }
  getItems() {
    let files = this.app.vault.getMarkdownFiles();
    if (this.sourceFolder) {
      const prefix = this.sourceFolder + "/";
      files = files.filter((f) => f.path.startsWith(prefix));
    }
    return files.sort((a, b) => a.basename.localeCompare(b.basename));
  }
  getItemText(item) {
    return item.basename;
  }
  onChooseItem(item) {
    this.onChooseFile(item);
  }
};
var SparkModal = class extends import_obsidian.Modal {
  constructor(app, noteA, noteB, contentA, contentB, settings, cairnProjects, onSpark, onSkip, onShuffle, onPick, onSettingsChange) {
    super(app);
    this.seenPaths = /* @__PURE__ */ new Set();
    this.noteA = noteA;
    this.noteB = noteB;
    this.contentA = contentA;
    this.contentB = contentB;
    this.settings = settings;
    this.cairnProjects = cairnProjects;
    this.onSpark = onSpark;
    this.onSkip = onSkip;
    this.onShuffle = onShuffle;
    this.onPick = onPick;
    this.onSettingsChange = onSettingsChange;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.addClass("fk-spark-modal");
    modalEl.addClass("fk-spark-modal-container");
    const header = contentEl.createDiv({ cls: "fk-header" });
    header.createEl("h3", { text: "Flint" });
    header.createEl("span", { cls: "fk-header-tagline", text: "Strike two ideas together" });
    const allFolders = [];
    this.app.vault.getAllLoadedFiles().forEach((f) => {
      if (f.children !== void 0 && f.path !== "/") {
        allFolders.push(f.path);
      }
    });
    allFolders.sort();
    const configRow = contentEl.createDiv({ cls: "fk-config-row" });
    const sourceGroup = configRow.createDiv({ cls: "fk-config-group" });
    sourceGroup.createEl("span", { cls: "fk-config-label", text: "from" });
    const sourceSelect = sourceGroup.createEl("select", { cls: "fk-config-select" });
    sourceSelect.createEl("option", { text: "All folders", value: "" });
    for (const folder of allFolders) {
      const opt = sourceSelect.createEl("option", { text: folder, value: folder });
      if (folder === this.settings.sourceFolder)
        opt.selected = true;
    }
    sourceSelect.addEventListener("change", async () => {
      this.settings.sourceFolder = sourceSelect.value;
      this.onSettingsChange();
      await this.shuffleBoth();
    });
    const outputGroup = configRow.createDiv({ cls: "fk-config-group" });
    outputGroup.createEl("span", { cls: "fk-config-label", text: "to" });
    const outputSelect = outputGroup.createEl("select", { cls: "fk-config-select" });
    outputSelect.createEl("option", { text: "Vault root", value: "" });
    for (const folder of allFolders) {
      const opt = outputSelect.createEl("option", { text: folder, value: folder });
      if (folder === this.settings.outputFolder)
        opt.selected = true;
    }
    outputSelect.addEventListener("change", () => {
      this.settings.outputFolder = outputSelect.value;
      this.onSettingsChange();
    });
    const columns = contentEl.createDiv({ cls: "fk-columns" });
    const panelA = this.buildPanel(columns, "A");
    const panelB = this.buildPanel(columns, "B");
    this.panelTitleA = panelA.titleEl;
    this.panelContentA = panelA.contentEl;
    this.panelTitleB = panelB.titleEl;
    this.panelContentB = panelB.contentEl;
    this.seenPaths.add(this.noteA.path);
    this.seenPaths.add(this.noteB.path);
    this.renderPanel("A");
    this.renderPanel("B");
    const writing = contentEl.createDiv({ cls: "fk-writing-area" });
    writing.createEl("label", {
      cls: "fk-writing-prompt",
      text: "What does this collision make you think?"
    });
    const textarea = writing.createEl("textarea", {
      cls: "fk-idea-textarea",
      placeholder: "The spark goes here\u2026"
    });
    const titleRow = writing.createDiv({ cls: "fk-title-row" });
    titleRow.createEl("span", { cls: "fk-title-label", text: "Title:" });
    const titleInput = titleRow.createEl("input", {
      type: "text",
      cls: "fk-title-input",
      placeholder: "Auto-suggested from your idea"
    });
    let titleManuallyEdited = false;
    titleInput.addEventListener("input", () => {
      titleManuallyEdited = true;
    });
    const updateTitle = (0, import_obsidian.debounce)(
      () => {
        if (titleManuallyEdited)
          return;
        const ideaText = textarea.value.trim();
        if (ideaText) {
          titleInput.value = ideaText.split("\n")[0];
        }
      },
      500,
      false
    );
    textarea.addEventListener("input", () => {
      updateTitle();
    });
    const projectCheckboxes = /* @__PURE__ */ new Map();
    if (this.cairnProjects.length > 0) {
      const projectSection = contentEl.createDiv({ cls: "fk-project-section" });
      projectSection.createEl("label", { cls: "fk-project-label", text: "Add to essays:" });
      for (const project of this.cairnProjects) {
        const checkRow = projectSection.createDiv({ cls: "fk-check-row" });
        const cb = checkRow.createEl("input", { type: "checkbox" });
        cb.id = `fk-project-${project.id}`;
        const label = checkRow.createEl("label", { text: project.name });
        label.setAttr("for", cb.id);
        projectCheckboxes.set(project.id, cb);
      }
    }
    const btnRow = contentEl.createDiv({ cls: "fk-btn-row" });
    const skipBtn = btnRow.createEl("button", { text: "Skip" });
    skipBtn.addEventListener("click", () => {
      this.onSkip(this.noteA, this.noteB);
      this.shuffleBoth(textarea, titleInput);
      titleManuallyEdited = false;
    });
    const saveBtn = btnRow.createEl("button", {
      cls: "mod-cta",
      text: "Save Spark"
    });
    const submit = async () => {
      const idea = textarea.value.trim();
      if (!idea) {
        new import_obsidian.Notice("Write something first \u2014 that's the spark!");
        return;
      }
      const title = titleInput.value.trim();
      if (!title) {
        new import_obsidian.Notice("Note title cannot be empty");
        return;
      }
      const folder = outputSelect.value;
      const selectedIds = [];
      projectCheckboxes.forEach((cb, id) => {
        if (cb.checked)
          selectedIds.push(id);
      });
      await this.onSpark(idea, title, folder, this.noteA, this.noteB, selectedIds);
      textarea.value = "";
      titleInput.value = "";
      titleManuallyEdited = false;
      projectCheckboxes.forEach((cb) => {
        cb.checked = false;
      });
    };
    saveBtn.addEventListener("click", submit);
    textarea.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        submit();
      }
    });
    setTimeout(() => textarea.focus(), 50);
  }
  buildPanel(parent, side) {
    const panel = parent.createDiv({ cls: "fk-panel" });
    const titleEl = panel.createDiv({ cls: "fk-panel-title" });
    titleEl.addEventListener("click", () => {
      const file = side === "A" ? this.noteA : this.noteB;
      this.app.workspace.openLinkText(file.path, "", true);
    });
    const contentEl = panel.createDiv({ cls: "fk-panel-content" });
    const actions = panel.createDiv({ cls: "fk-panel-actions" });
    const shuffleBtn = actions.createEl("button", {
      cls: "fk-action-btn",
      text: "Shuffle"
    });
    shuffleBtn.addEventListener("click", () => {
      this.shuffleOne(side);
    });
    const pickBtn = actions.createEl("button", {
      cls: "fk-action-btn",
      text: "Pick\u2026"
    });
    pickBtn.addEventListener("click", () => {
      this.onPick((file) => {
        this.replaceNote(side, file);
      });
    });
    return { titleEl, contentEl };
  }
  renderPanel(side) {
    const titleEl = side === "A" ? this.panelTitleA : this.panelTitleB;
    const contentEl = side === "A" ? this.panelContentA : this.panelContentB;
    const note = side === "A" ? this.noteA : this.noteB;
    const content = side === "A" ? this.contentA : this.contentB;
    titleEl.empty();
    titleEl.setText(note.basename);
    contentEl.empty();
    contentEl.setText(content);
  }
  async replaceNote(side, file) {
    const content = await this.app.vault.read(file);
    if (side === "A") {
      this.noteA = file;
      this.contentA = content;
    } else {
      this.noteB = file;
      this.contentB = content;
    }
    this.renderPanel(side);
  }
  shuffleOne(side) {
    const exclude = [...this.seenPaths];
    const newNote = this.onShuffle(exclude);
    if (!newNote) {
      this.seenPaths.clear();
      this.seenPaths.add(this.noteA.path);
      this.seenPaths.add(this.noteB.path);
      const retry = this.onShuffle([...this.seenPaths]);
      if (!retry) {
        new import_obsidian.Notice("No more notes to shuffle \u2014 try broadening your source folder.");
        return;
      }
      this.seenPaths.add(retry.path);
      this.app.vault.read(retry).then((content) => {
        if (side === "A") {
          this.noteA = retry;
          this.contentA = content;
        } else {
          this.noteB = retry;
          this.contentB = content;
        }
        this.renderPanel(side);
      });
      return;
    }
    this.seenPaths.add(newNote.path);
    this.app.vault.read(newNote).then((content) => {
      if (side === "A") {
        this.noteA = newNote;
        this.contentA = content;
      } else {
        this.noteB = newNote;
        this.contentB = content;
      }
      this.renderPanel(side);
    });
  }
  shuffleBoth(textarea, titleInput) {
    const excludeA = [];
    const newA = this.onShuffle(excludeA);
    if (!newA)
      return;
    const newB = this.onShuffle([newA.path]);
    if (!newB)
      return;
    Promise.all([
      this.app.vault.read(newA),
      this.app.vault.read(newB)
    ]).then(([cA, cB]) => {
      this.noteA = newA;
      this.noteB = newB;
      this.contentA = cA;
      this.contentB = cB;
      this.renderPanel("A");
      this.renderPanel("B");
      if (textarea)
        textarea.value = "";
      if (titleInput)
        titleInput.value = "";
      if (textarea)
        setTimeout(() => textarea.focus(), 50);
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var FlintPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("flame", "Flint \u2014 Strike two ideas", () => {
      this.openSpark();
    });
    this.addCommand({
      id: "open-spark",
      name: "Strike two notes",
      callback: () => this.openSpark()
    });
    this.addSettingTab(new FlintSettingTab(this.app, this));
  }
  async openSpark() {
    const noteA = getRandomNote([], this.app, this.settings);
    const noteB = getRandomNote(
      noteA ? [noteA.path] : [],
      this.app,
      this.settings
    );
    if (!noteA || !noteB) {
      new import_obsidian.Notice(
        "Not enough notes to spark from. Add more notes to your vault."
      );
      return;
    }
    const contentA = await this.app.vault.read(noteA);
    const contentB = await this.app.vault.read(noteB);
    const cairnProjects = this.settings.showEssayProjects ? await getCairnProjects(this.app) : [];
    const modal = new SparkModal(
      this.app,
      noteA,
      noteB,
      contentA,
      contentB,
      this.settings,
      cairnProjects,
      // onSpark
      async (idea, title, folder, fileA, fileB, selectedProjectIds) => {
        await this.createSparkNote(idea, title, folder, fileA, fileB, selectedProjectIds, cairnProjects);
      },
      // onSkip
      (fileA, fileB) => {
        this.logSpark(fileA.path, fileB.path, "skipped");
      },
      // onShuffle
      (exclude) => getRandomNote(exclude, this.app, this.settings),
      // onPick
      (onChoose) => {
        new NotePickerModal(
          this.app,
          this.settings.sourceFolder,
          onChoose
        ).open();
      },
      // onSettingsChange
      () => {
        this.saveSettings();
      }
    );
    this.activeModal = modal;
    modal.open();
  }
  async createSparkNote(idea, title, folder, noteA, noteB, selectedProjectIds, cairnProjects) {
    const safeName = sanitizeFilename(title);
    if (!safeName) {
      new import_obsidian.Notice("Note title cannot be empty");
      return;
    }
    const targetPath = folder ? `${folder}/${safeName}.md` : `${safeName}.md`;
    if (this.app.vault.getAbstractFileByPath(targetPath)) {
      new import_obsidian.Notice(`File "${targetPath}" already exists`);
      return;
    }
    const lines = [
      idea.trim(),
      "",
      "---",
      "",
      "## Sparked from",
      "",
      `- [[${noteA.basename}]]`,
      `- [[${noteB.basename}]]`,
      ""
    ];
    await this.app.vault.create(targetPath, lines.join("\n"));
    this.logSpark(noteA.path, noteB.path, "sparked", targetPath);
    if (selectedProjectIds.length > 0) {
      const sparkFile = this.app.vault.getAbstractFileByPath(targetPath);
      if (sparkFile instanceof import_obsidian.TFile) {
        for (const projId of selectedProjectIds) {
          const proj = cairnProjects.find((p) => p.id === projId);
          if (proj) {
            await this.addToEssay(sparkFile, proj);
          }
        }
      }
    }
    const frag = document.createDocumentFragment();
    frag.append("Sparked ");
    const link = document.createElement("a");
    link.textContent = safeName;
    link.style.cursor = "pointer";
    link.style.textDecoration = "underline";
    link.addEventListener("click", () => {
      if (this.activeModal)
        this.activeModal.close();
      const f = this.app.vault.getAbstractFileByPath(targetPath);
      if (f instanceof import_obsidian.TFile)
        this.app.workspace.getLeaf(false).openFile(f);
    });
    frag.append(link);
    new import_obsidian.Notice(frag, 8e3);
  }
  async addToEssay(sparkFile, project) {
    const projectFile = this.app.vault.getAbstractFileByPath(project.filePath);
    if (!(projectFile instanceof import_obsidian.TFile))
      return;
    let sparkContent = await this.app.vault.read(sparkFile);
    sparkContent = sparkContent.replace(/^---\n[\s\S]*?\n---\n?/, "");
    const headingPattern = new RegExp(
      `^#\\s+${sparkFile.basename.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\s*
?`
    );
    sparkContent = sparkContent.replace(headingPattern, "").trim();
    const projectContent = await this.app.vault.read(projectFile);
    const quoted = sparkContent.split("\n").map((l) => `> ${l}`).join("\n");
    const newSection = `## ${sparkFile.basename}

${quoted}

`;
    const sourcesMatch = projectContent.match(/^(## Sources)\s*$/m);
    let newContent;
    if (sourcesMatch && sourcesMatch.index !== void 0) {
      const before = projectContent.slice(0, sourcesMatch.index);
      const sourcesBlock = projectContent.slice(sourcesMatch.index);
      const updatedSources = sourcesBlock.trimEnd() + `
- [[${sparkFile.basename}]]`;
      newContent = before.trimEnd() + "\n\n" + newSection + "\n\n" + updatedSources + "\n";
    } else {
      newContent = projectContent.trimEnd() + "\n\n" + newSection + "\n";
    }
    await this.app.vault.modify(projectFile, newContent);
  }
  logSpark(noteA, noteB, result, sparkNote) {
    this.settings.sparkHistory.push({
      noteA,
      noteB,
      result,
      sparkNote,
      timestamp: Date.now()
    });
    if (this.settings.sparkHistory.length > 200) {
      this.settings.sparkHistory = this.settings.sparkHistory.slice(-200);
    }
    this.saveSettings();
  }
  async loadSettings() {
    const saved = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, saved);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var FlintSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const folders = this.getFolders();
    new import_obsidian.Setting(containerEl).setName("Source folder").setDesc("Which notes to draw from when shuffling. Leave blank for all folders.").addDropdown((drop) => {
      drop.addOption("", "All folders");
      for (const f of folders) {
        drop.addOption(f, f);
      }
      drop.setValue(this.plugin.settings.sourceFolder);
      drop.onChange(async (val) => {
        this.plugin.settings.sourceFolder = val;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Output folder").setDesc("Where new spark notes are saved.").addDropdown((drop) => {
      drop.addOption("", "Vault root");
      for (const f of folders) {
        drop.addOption(f, f);
      }
      drop.setValue(this.plugin.settings.outputFolder);
      drop.onChange(async (val) => {
        this.plugin.settings.outputFolder = val;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Prefer orphan notes").setDesc(
      "Weight random selection toward notes with fewer connections. Orphans are dormant potential."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.includeOrphans);
      toggle.onChange(async (val) => {
        this.plugin.settings.includeOrphans = val;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Show essay projects").setDesc(
      "Show Cairn essay project checkboxes when saving a spark. Disable if you don't use Cairn."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showEssayProjects);
      toggle.onChange(async (val) => {
        this.plugin.settings.showEssayProjects = val;
        await this.plugin.saveSettings();
      });
    });
    const history = this.plugin.settings.sparkHistory;
    if (history.length > 0) {
      const sparked = history.filter((e) => e.result === "sparked").length;
      const skipped = history.filter((e) => e.result === "skipped").length;
      containerEl.createEl("hr");
      const statsDiv = containerEl.createDiv({ cls: "fk-stats" });
      statsDiv.createEl("h4", { text: "Spark history" });
      statsDiv.createEl("p", {
        text: `${sparked} sparked, ${skipped} skipped (${history.length} total)`
      });
    }
    containerEl.createEl("hr");
    const about = containerEl.createDiv({ cls: "fk-about" });
    about.createEl("p", {
      text: "Flint is free and open source. Built by Maggie McGuire."
    });
  }
  getFolders() {
    const folders = [];
    this.app.vault.getAllLoadedFiles().forEach((f) => {
      if (f.children !== void 0 && f.path !== "/") {
        folders.push(f.path);
      }
    });
    return folders.sort();
  }
};
